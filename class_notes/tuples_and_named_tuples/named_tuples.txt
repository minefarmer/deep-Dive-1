                            Tuple as Data Structure

We have seen how we interpreted tuples as data structures.

The position of the object contaned in the tuple gave it meaning.

For example, we can represent a 2D coordinate as:   (10, 20)
                                                     |   |
                                                     x   y

If pt is a position tuple, we can retrieve the x and y coordinates using:   x, y = pt       or  x = pt[0]
                                                                                                y = pt[1]

So, for example, to calculate the distance of pt from the origin we could write:
    dist = math.sgrt(pt[0] ** 2 + pt[1] **2)

Now that's not very readable, and if someone sees this code they will hav to know thatpt[0] means the x-coordinate and pt[1] means the y-coordinate.

This is not very transparent.

        Using a class instead   *************************

At, this point, in order to make things clearer for the reader (not the complier, the reader), we might want to approach this using a class instead.

class Point2d:
    def __init__(self, x, y)        pt= Point2D(10, 20)
        self.x = y           distance = sqrt(pt.x **2 + pt.y **2)
        self.y = y                 "        "       "

claass Stock:
    def __init__(self, symbol, year, month. day, open, high, low, close):
        self.symbol = symbol
        self.year = year
        self.month = month
        self.day = day          Class approach          Tuple 
        self.open = open
        self.high = high        djia.symbol             djia[0]
        self.low = low          djia.open               djia[4]
        self.close = close      djia.close              djia[7]

                                djia.high - djia.low    djia[5] - djia[6]

        Extra stuff  *************************************************

The very least we should implement the __repr__method
    -> Point(10, 20) == Point(10, 20) -> True

Class Point2D:
    def __repr__(self):
        self.x = x
        self.y = y

    def __repr__(self):
        return f'Point2D(x={self.x}, y={self.y}'

    def __eq__(self, other)
        if isinstance(other, Point2D):
            return self.x == other.x and self.y == other.y
        else:
            return False


            Named Tuples to the rescue *********************************************
There are reasons to seek another approach. He covers some of these in the coding video.

Among other things,Point2d objects are mutable - something I may not want!

There's a lot to like using tuples to represent simple data structures.

The real drawback is that we have to know what the positions mean, and remember this in our code.

If we ever need to change the structure of our tuple in our code 9 (like inserting a value that we forgot), most likely our code will break!

eric = ('Idle', 42)         eric = ('Eric'. 'Idle', 42)

last_name, age = eric       last_name, age = eric   # Broken 


Class approach:     last_name = eric.last_name
                    age = eric.age


So what if we could somehow combine these two approaches, essentially creating tuples where we can in addition, give meaningful names to the positions?

That's what namedtuples essentially do.

They subclass tuple, and add a layer to assign property names to the positional elements.

Located in the collections standard library module.

from collections import namedtuple

Named tuple is a function,      which generates a new class     -> class factory

    That new class inherits from tuple

    but, also provides named properties to access elements of the tuple

    but, an instance of that clss is still a tuple.

We have to understand that namedtuple is a class factory.

When we use it, we are essentially creating a new class, just as if we had used class ourselves.

namedtuple needs a fe tings to generate this class:

    The class name we want to use.
    A sequence of field names (strings) we want to design, in the order of the elements in the tuple.
        field names can be any variable name,
        except that they cannot start with an underscore.

The return value of the call to namedtuple will be a class.

We need to assign that class to a variable name in our code so we can use it to construct instances.

In gerenal, we use the same name as the name of the class that was generated.

Point2D = namedtuple('Point2D', ['x', 'y'])

We can create instances of Point2D just as we would with any class (since it is a class)

pt = Point2D(10, 20)

The variable name that we use to assign to the class generated and returned by namedtuple is arbitrary.

Pt2d = namedtuple('Point2D',['x', 'y'])

pt = Pt2D(10, 20)

                    Variable: MyClass --->  Class:
class MyClass:                             MyClass
    pass                                 /
                Variable: MyClassAlias  /

MyClassAlias = MyClass

instance_1 = MyClass()      instance_2 = MyClassAlias()     instantiates the same class

Similarly

Pt2DAlias = namedtuple('Point2D', ['x', 'y'])

                                          0xFF900
                                      Class
        Variable: Pt2DAlias -------> PointD

This is the same concept as aliasing a function, or assigning a lambda function to a variable name!

There are many ways I can provide the list offield names to the namedtuple function.
    a string
    a tuple of strings      --> in fact any sequence, just remember that order matters
    a single string with the field names seperated by whitespace or commas.
            namedtuple( 'Point2D', ['x', 'y'])

            namedtuple('Point2D', ('x'), 'y')

            namedtuple_'Point2D', ('x', 't')

            namedtuple(Point2D', 'x y')

After we have created a named tuple class, we can instantite them just like an ordinary class.

In fact, the __new__ method of the generated class uses the field names we provided as param names.

Point2D = namedtuple( 'Point2D', 'x y')


I can use positional arguments:
pt1 = Point2D(10, 20)     10 -> x   20 -> y

And even keyword arguments:
pt2 = Point2D(x=10, y=20)     10 -> x   20 -> y


        Accessing Data in a named Tuple  ****************************************************************

Since named tuplesare also regular tuples, we can still handle them just like any other tuple.
    by index
    slice
    iterate


Point2D = namedtuple( 'Point2D', 'x y')

pt1 = Point2D(10, 20)                 isinstance(pt1, tuple)  --> True


            x, y = pt1

            x = pt1[0]

            for e in pt1:
                print(e)


But now, in addition, we can also access the data using the field names:


Point2D = namedtuple( 'Point2D'), 'x y')
pt1 = Point2D(10, 20)

pt1.x  -> 10
pt1.y  -> 20

Since namedtuple generated classes inherit from tuples      class Point2D(tuple):
                                                                ...

pt1 is a tuple, and is therefore immutable.


            The remane keyword only argument for namedtuple

Remember that field names for named tuples must be valid identifiers, but, cannot start with an underscore.

This would not work: Person = named tuple('Person', 'nam age _ssn')


namedtuple has a keyword-only argument, rename  (default to False) that will automatically rename any invalid field name.

uses convention:  _{position in list of field names}

We can easily find out the fiel names in a named tuple generated class.
class property -> _fields

Remember that namedtuples is a class factory, i.e. it generated a class.


            Instance method:_asdict()

It will create a dictionary f all the named values in the tuple.

Point2D = namedtuple( 'Po', 'x,y')
pt1 = Point2D(10, 20)

pt1._asdict()   -> {'x': 10, 'y',: 20}
