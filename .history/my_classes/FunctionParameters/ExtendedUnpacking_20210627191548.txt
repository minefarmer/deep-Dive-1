        The use case for extended unpacking.

We don't always want to unpack every single item in an iterable.
We may, for example, want to unpack the first value, and then unpack the remaining values into another variable.

l = [1, 2, 3, 4, 5, 6]

We can achieve this using slicing:      a = l[0]
                                        b = l[1:]

or, using simple unpacking:             a, b = l[0], l[1:]      (aka parallel assignment)

We can also use the * operator:         a, *b = l



        Usage with ordered types

a, *b = [-10, 5, 2, 100]        a = -10     b = [5, 2, 100]

a, *b = (-10, 5, 2, 100)        a = -10     b = [5, 2, 100] <----- this is still a list!

a, *b = 'XYZ'                   a = 'XYZ'   b = ['Y', 'Z']  <----- this is also a list



        The following also works:

a, b, *c = 1, 2, 3, 4, 5        a = 1       b = 2       c = [3, 4, 5]


        We can add elements after the last elements.

a, b, *c, d = [1, 2, 3, 4, 5]   a = 1       b = 2       c = [3, 4]      d = 5

a, *b, c, d = 'python'      a = 'p'     b = ['y', 't', 'h']     c = 'o'     d = 'n'



        The * operator can only be used once in the LeftHandSide an unpacking assignment.

a, *b, *c = [1, 2, 3, 4, 5, 6]
Since both *b and *c mean "the rest". both cannot exhaust the remaining elements.



        Usage with ordered types.

We have seen how to use the * operator in the LHS of an assignment to unpack the RightHandSide
a, *b, c = {1, 2, 3, 4, 5}

However, we can also use it this way:
l1 = [1, 2, 3]
l2 = [4, 5, 6]
l = [*l1, *l2]      -> l = [1, 2, 3,4, 5, 6]

l1 = [1, 2, 3]
l2 = 'XYZ'
l = [*l1, *l2]      -> l = [1, 2, 3, 'X', 'Y', 'Z']



        Usage with unordered types.
Unpacking is rarely used with sets and dictionaries.  # Because they are unordered.

Types such as sets and dictionaries have no ordering.
s = {10, -99, 3, 'd'}
print(s)            ->{"d", 3, -99, 10}

Sets and dictionary keys are still iterable, but iterating has no guantee of preserving the order in which the elements were created/added.

But. the * operator still works, since it works with any iterable.

s = {10, -99 3, 'd}
a, *b, c = s        a = 10  b = [3, 'd']    c = -99

### It is useful though in a situation where you might want to create single collection containing all the items of multiple sets, or all the keys of multiple dictionaries.

d1 = {'p': 1, 'y': 2}

d2 = {'t': 3, 'h': 4}

d3 = {'h': 5, 'o': 6, 'n': 7}   Note that the key 'h' is in both d2 and d3
